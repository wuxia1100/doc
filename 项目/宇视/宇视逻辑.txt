1 部门和国家渠道
	1 添加部门时会创建渠道，第5级部门(userinfo_sort = 5)，会推送成为国家渠道 类型（CHANNEL_TYPE = 8）
2 客户和客户渠道
	1 添加一个客户时，会创建一个客户渠道  （CHANNEL_TYPE = 0 and CHANNEL_SORT = 2）
3 商品和sku
	1 原型机添加：会添加商品表，sku,file等
	2 商品发布：选择原型机，会添加商品表，sku,file等
	3 商品上架：会把商品推送到国家渠道，所有类型（CHANNEL_TYPE in (5，6，7)的渠道都会推送，每一个渠道，复制一份商品信息给自己（商品表，sku,file等）

4 订单提审
	1 提交提审 2 修改订单
			   3 查询下一步订单节点：a 校验订单状态：是否发货，是否支付
									 b 1 从数据库查询订单流程ocCProcess  2 从缓存中，通过key,field查询订单流程节点 ocCflowNode（父节点）
									   3 从缓存中，通过key,field查询订单流程节点 ocCflowNode（父节点），通过父节点，获取所有子节点
									   4 构建流程：开启方式：start 业务，
									   5 更新支付状态？
1 订单引擎：可以控制订单流程：存放当前流程节点	，通过订单引擎中的流程code，可以获取当前流程
2 订单流 2 订单流节点 3 订单流节点，服务  4 订单流程() 5 订单流程引擎
3 节点构建流程，流程被执行于引擎
4 遍历所有节点，所有需要执行的节点，构建流程
5 保存所有流程，遍历更新订单引擎，为什么订单引擎是在这里更新？为什么在每一个节点中都要执行一次订单分次支付的修改？

5 下单
	1 检验订单信息 2 组装订单 3 删除购物车 4 保存订单（订单，包裹，结算，扩展，订单引擎） 5 返回到入口处，启动订单引擎
	6 查询节点，创建流程，保存流程，返回流程到入口处，
	7 把流程加入到队列 8 线程拉取队列信息，处理信息，主要看拉流线程是如何处理的，推流线程只是存放数据到队列中
	9   订单节点：
		> 1 订单引擎：查询，组装，返回，存入队列，拉取队列处理 
		> 2 订单流程: 查询，组装，返回,存入队列,拉取队列处理 
		> 3 订单节点: 查询，组装，返回,存入队列，拉取队列处理
		> 4 节点服务：处理节点，查询节点对应的服务，根据服务里的路由，调用具体的方法，处理节点，服务需要处理的业务逻辑
		> 5 更新流程：节点服务处理完具体的业务之后，返回处理结果，根据处理结果，更新订单流程的处理状态
		> 6 更新引擎：更新订单引擎的状态，处理到哪个流程节点了，这里还处理了分批支付的东西是我不能理解的，为啥在这里
		> 7 是否结束：流程没有结束，则继续组装订单流程（第2步）,返回到第3步，处理订单节点，
		> 8 不断轮询（3-8），直到节点结束或异常
6 异步轮询：闭环:A-B-A : A 是闭环开始的入口 B 是闭环里的业务处理 ,B最后再调用A ：这样就是无限循环，什么时候资源处理完什么时候结束
	1 资源 2 存入队列 3 使用队列 4 处理(具体的路由方法)-返回资源-(2 存入队列 3 使用队列 4 处理) 5 轮询处理：
	每次处理完，都会返回需要处理的资源，重新存入队列，如果从队列中拿到数据就处理，直到拿不到数据，数据全部处理完为止
	2 a 资源 b 闭环 > 闭环体系，处理资源 相当于while(true),相当于死循环，A > B,B > A,2个节点的闭环
	3 A 调用B:是为了处罚业务处理
	5 B 调用A:是为了构成闭环结构，轮询处理业务
	6 A-A:A调用A的循环，同样是资源判定
7 流程
	1 校验数据（数据是否合法，不为空等） 2 查询数据 3 校验数据业务状态（是否符合处理状态） 4 组装数据 5 处理业务
8 组装发送数据
	1 发送给谁，做什么业务处理？为什么不直接处理，保存发送的数据有啥用？
	2 发送给谁 是保存流水的时候设置的，可以手动设置，也可以从数据库表查询配置好的路由，封装流水数据
9 操作预处理
	1 每次处理业务之前，都会有一些列操作预处里的数据组装，保存，好多层之后才开始正真处理功能业务，之前的都属于框架业务
	框架为了性能，或或许功能，需要做一些列这些事
	2 大量的前期准备工作，最后就是处理返回的数据
10 渠道规则生效
	1 删除商品信息 2 封装商品变更流水 3 保存商品变更流水 4 返回商品变更流水

	
