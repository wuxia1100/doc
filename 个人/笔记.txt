1 javac 编译class文件时，如果编译出相同的类名时，后编译的会覆盖先编译的类容
2 配置路径时"." 符合的意思时 当前目录，配置注意是配置系统变量，不算用户变量
   配置了path路径: 可以在任意目录下使用jdk里的命令工具，例如：javac 编译Java文件
   配置了classpath路径：可以在任意目录下运行配置路径下存在的class文件
   不配置classpath路径：1 可以引用jdk的类库，2 可以在.class文件当前目录下运行class文件，不可以在目录以外运行
	项目集成了jdk，编译后的class文件应该会放到配置的calsspath目录下
	.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar 

Java语法
1 关键字：1 组成关键字的字母全部小写 2 高级记事本对关键字有特殊的颜色标记


2 数据类型转换：内存 小  转 大  默认 ， 内存 大  转 小   强制（损失精度），强制转换类型必须声明出来，不然默认是错误，强制
程序员要知道这个数据确实可以强转，损失精度也可以

3 常量 先计算 再赋值，看结果是否在内存范围内，变量  先看数据类型  内存大的不能赋值给内存小的

4 匿名对象：使用场景此对象只使用一次的时候使用  new Student();
 好处：使用完立马被垃圾回收器回收
 可以作为参数传递
5  方法里的叫形式参数  ，类中定义的是实参

6 对象成员变量私有化，保证一些操作必须用对象里的方法进行，这样可以避免误操作

7  变量的使用原则，就近原则，作用域从小到大，从内到外

8 this  Java提供了代表当前类的对象关键字，而不是当前类初始化的某个对象
		当前类的对象引用，谁调用这个方法（初始化的对象），this就代表谁
9 构造方法: 作用 给类的成员初始化
	1 方法名与类名相当
	2 方法没用返回值，连void都没有
	3 字定义构造方法，系统将不再提供默认的无参构造方法
	4 构造方法的重载格式
	5 如果定义了有参构造函数，这时想要使用无参构造函数，要自己定义，也就是定义了原先默认的就没有了
10 成员变量：只有跟类有关系时才定义，变量定义的范围越小越好（及时被回收）
11 import 必须在所有的class前
12 static 多个对象使用同一个值，被所有对象共享
	随着类的加载而加载
	优先于对象存在，对象创建才有
	可以直接通过类名调用，推荐使用类名调用，一般称为类成员，而不是对象成员
	是否使用静态 ：举例 饮水机（用静态修饰）   水杯（不用静态修饰）
	注意：静态方法中没有this关键字
			静态随着类的加载而加载，this随着对象的创建而存在
			静态比对象先存在
		  静态方法只能访问静态的成员变量和静态的成员方法
	静态只能访问静态，非静态可以访问一切
	问题：如何在静态方法内使用非静态方法：只需要在静态方法内先创建对象，用对象调用非静态
			方法即可,原因是创建了对象之后，非静态方法也一定被加载到内存中，静态区内调用
			不可能出现找不到或者先后顺序上的逻辑错误，不存在逻辑错误，就符合Java语法
13  mian 方法中的String[] args 早期时为了接收键盘录入的数据
	格式是  java  类名  参数1 参数2 ...
	jdk1.5以后 出现了更好用的Scanner键盘录入类
14  static 的使用， 私用化构造方法，静态成员方法，这样的工具类，别人只能通过类名调用
15 Java类说明书的制作 javadoc -d doc -author - version ArrayTools.java
16 java.lang 包下的类不需要导入
17 代码块：局部代码块（方法内）  构造代码块（类中成员位置）：提取构造方法内相同的代码，对对象初始化
			静态代码块：成员位置，用{}括起来，要static修饰，只在类第一次加载的时候一并执行，对类初始化
18 继承：复用性，容易维护，类与类之间关系，是多态的前提
		只支持单继承，不支持多继承，有些语言支持多继承
		如果父类没有无参构造函数，子类必须在所有的构造函数里调用父类构造函数，否在无法创建父类对象，因为
		找不到默认的构造函数
	分层初始化，先初始化父类对象，再初始化子类对象，初始化动作开始，执行的代码不是从构造
	函数那行开始，构造函数的代码，在对象空间创建好后，对成员属性进行赋值（猜测）
	方法重写：Java调用机制的一种体现，就近原则，在此基础上附加上父类原有的功能super().方法
	整体就是方法重写的应用
	子类中重写的方法权限必须不比父类低，不然报错，无法分配权限
	父类中静态，子类也必须是静态，父类是非静态，子类也必须是非静态，也就是要一致
19 代码 ：低耦合 ，高内聚
20 super代表父类存储空间的标识
21 this(...),super(...) 调用构造函数，必须出现在第一条语句上，如果不放在第一条语句，
	就可能对父类进行多次初始化,因为子类构造函数第一句默认是super()
22 private 标识，只能在本类中使用，外面不能访问，外面创建了类的对象也不能访问
23 多态的前提是继承关系，只有重写之后多态才有意义，多态的表现是父类引用 指向子类对象，
	父类引用调用子类重写的方法，这部分重写的方法就是父类在不同时候表现出的不同状态
	父类引用不要子类对象里其它任何成员属性，只要重写的部分
	好处：可扩展性 这里是针对于对象的扩展使用，一系列对象（重写相同的逻辑）不确定还有多少时，就可以使用多态
	这样逻辑处理部分可以通过多态不用管具体对象是谁，只用管调用处理重写的逻辑，使用处负责传入具体的多态
	父类引用  可以接收任何子类对象
	多态就是重写
24 抽象类，抽象方法 定义的时候不应该有具体的实现，一个类如果有抽象方法，这个类必须时抽象的
	成员方法  可以是非抽象的 子类继承提高代码复用性
			  抽象方法  强制子类必须重写，要求子类做事情
25 语法 就是语言规范  ，逻辑规范，制定逻辑，不要乱来，才能玩的转
26 接口不能实例化  运用多态实例化
	接口中的变量默认是常量，并且是静态的
	接口中没有构造方法
	接口中方法默认是抽象的，默认修饰符
	接口与接口之间可以单继承，也可以多继承
27 内部类：在一个类里面 定义一个类，内部类可以访问外部的成员包括私有，外部访问内部类，必须创建对象
	位置不同：成员内部类   局部内部类
	私有化内部类，不让外面直接操作  为了数据安全
	内部类可以用静态修饰，因位可以看作外部类的成员，，为了访问方便
	静态域只能直接访问静态域里的成员
	Outer.this.成员  外部类名限定this
28 匿名内部类：实现或重写简单的接口或抽象类时 会很简单，只使用一次
	是一个继承抽象类或实现接口的对象 格式：new 类名(){ 重写/实现...};
29 jdk安装32位 eclipse也使用32位，看jdk版本
30 new Scanner(System.in) 包装的好处，可以实现很多实用的功能
31 字符串String
	1 直接赋值 是在方法区里常量池中开辟一块空间存放，
	2 拼接字符串 在常量池开辟一块空间存放拼接后的字符串，并把地址重新赋值给变量名
	3 字符串一旦被赋值就不能被改变：空间存放的值不会改变，引用地址可以改变
	4 String s1 = new String("hello"); String s2 = "hello"; String s3 = "world"; String s4 = "helloworld";
	  s1 == s2  //false   对象比较地址值，两者地址值不同，一个在堆中创建，一个在字符串常量池
	  s1.equals(s2) //true String类重写了Object类的equals方法，比较的是两个值
	  前者创建2个或1个对象，后者创建一个或0个对象：因为两者相同，在常量池只会创建一次，两者都指向它的地址值
	  s4 == s2 + s3 //false 两字符串变量做拼接，不会直接找值，会在常量池新开辟空间做拼接
	  s4 == "hello" + "world" //ture  //常量相加是先把常量值加起来（编译后直接完成，不需要代码运行时再做，因为这是一定的），然后看常量池有helloworld ,两者指向同一个地址值
31  char字符再加减乘除 比较时会自动转成ASCII码值
32 接口:1 空方法  这是接口是作为标记使用，跟强制转换一个道理，强制开发者使用，要开发者知道自己在做这个事，且需要
33 JavaApi在长度方面一般是包含左边 不包含右边
34 String 和 StringBuffer 作为形式参数 赋值，Sring 方法内改变不影响外部，StringBuffer方法内赋值不影响外部
35 就jdk5以后新特性，自动装箱  自动拆箱，赋值和逻辑运算时有这种特性，如果时比较没有这种特性
	-128 到 127 会直接从缓冲池里获取数据不会重新创建空间
36 Pattern 和 Matcher   group()方法使用前 必须先调 find()方法中的String
37 正则 字符  \w	 单词边界 \b  数量符
38 方法的嵌套调用，方法链式编程
39 Random 默认种子时当前毫秒值，给定种子后返回的随机数是相同的
40 集合存放基本类型时，实际上存放的是对应的包装类，这里会有一个装箱的动作
41 泛型：是一种特殊的类型，是把类型放在创建对象或者调用方法的时候明确的
		 可以是任意类型，告诉下面使用的代码，下面使用时都是这种类型
		 参数化类型：放类型当作参数的方式传递
		 好处：把运行时的问题提前到了编译时，避免了强转，
		 泛型高级通配符：<?> 任意类型 <? extends E> 向下限定本身及其子类 <? super E> 向上限定 本身及其父类
		 泛型高级通配限定的是多态使用时，创建子类对象时传入的类型
42 静态导入 import static 包名.类名.方法名：方法只能是静态的，如果有多个同名的方法名必须加前缀
43 方法可变参数：sum(int... a),方法定义时不确定，使用时才确定，这里的变量是一个数组
   如果有多个其它参数，可变参数一定放在最后，底层写法其实就是用数组接收的
   调用方法时可以传入一个数组，也可以传入多个参数，本质时一样的，jdk会把多个参数转成数组
44 异常：出现异常 结束程序 只是当前请求的线程当前这个动作停止，不是整个服务器项目结束
	编译期异常：编写时必须处理，否则无法编译，强制程序员知道这里会出问题，并且知道要如何做
		抛出：将来调用者必须处理
		强制调用者做处理，也可以是把内部问题传递到外部做出来（问题处理传递）
		也可以不是异常，就是xiang
	运行时异常：无需处理，因为这是代码bug,可以通过优化代码解决
		抛出：将来调用者可以不处理
	继承中：父类中方法没有抛出异常，子类重写方法时也不能抛出异常，父类抛出异常，子类只能抛出异常本身或其子类异常
45  递归：方法内部调用自己 public void show(){ show();};
		1 递归一定要有出口，否则就是死递归
		2 递归的次数不能太多，否则内存溢出
		3 构造方法不能递归使用
		分解  合并   到扒皮
		可以递归的一定是有某种规律
46 流操作：
	用完之后一定要释放资源 close(); 通知系统释放，不然服务器会越来越卡
	FileOutPutStream fos = new FileOutPutStream(path,apend);如果没有第二个参数，是重写写入
	相当于删掉原先文件重新创建新文件写入，如果第二个参数是true则是追加写入
47  字符做了加减法，就变成数值对应ASCLL
	System.out.print('\r'+0)  //13
48 	序列化流   对象 》 流    就是把对象写到文件或在网络中传输
	反序列化流 流   》 对象  把文件或网络中传输的流对象读取还原成对象
49 多线程 
	意义：
	1、吞吐量：你做WEB，容器帮你做了多线程，但是他只能帮你做请求层面的。简单的说，可能就是一个请求一个线程。或多个请求一个线程。
	如果是单线程，那同时只能处理一个用户的请求。
	2、伸缩性：也就是说，你可以通过增加CPU核数来提升性能。如果是单线程，那程序执行到死也就利用了单核，
	肯定没办法通过增加CPU核数来提升性能。鉴于你是做WEB的，第1点可能你几乎不涉及。
	那这里我就讲第二点吧。--举个简单的例子：假设有个请求，这个请求服务端的处理需要执行3个很缓慢的IO操作（
	比如数据库查询或文件查询），那么正常的顺序可能是（括号里面代表执行时间）：
	第二点体现在可以优化的项目功能，提高性能，或者必须要高效处理的功能（短时间内，处理极大量的业务逻辑）
	public class Threadextends Objectimplements Runnable
	Java没办法直接创建线程，它是封装通过C++实现的
	线程调度：1 轮流执行 2 抢占式执行 按优先级高低，如果相同则随机	
	Java线程调度的方法是抢占式
	线程优先级1-10：由于存在随机性，所以虽然优先级高的但不一定一定先执行，仅仅是概率高
	join()：线程加入，该线程执行结束，其它线程才会开始执行：相当于绝对最高优先级
    yield():暂停当前执行的线程，让其它线程执行以后，能在一定程度让线程执行和谐，一人一次，但不是绝对的
	setDaemo():守护线程，在线程开始前设置，如果都是守护线程，JVM退出  （坦克大战）
	interrupt():中止线程：把线程状态中止：抛出异常，继承执行线程里下面的代码
	stop():停止线程：杀掉线程，立马停止，线程里下面的代码不会被执行
	周期：新建（创建线程对象） 
		> 就绪（有执行资格，没有执行权） 
		> 运行 （有执行资格，有执行权）
			阻塞 由于一些操作让线程处于该状态 没有执行资格，没有执行权，而另一些操作可以把它激活，激活后就绪状态
			sleep(),wait() 阻塞 ， sleep()时间到，notify()唤醒
			运行 到 就绪 （执行权被别的线程抢走）
		> 死亡（线程对象变成垃圾等待被回收） run()结束，中断线程（stop，interrupt）
	实现方式：
		1 继承Thread类 
		2 实现Runable接口（1 解决了单继承的局限性 2 代码数据分离，适用于多个对象去处理同一个资源）
	模拟3个窗口卖100张票
	CPU 的一次操作必须时原子性的，会出现卖相同的票
	延迟和随机性：会出现负数的情况
	线程安全问题：1 是否多线程 2 是否共享数据 3 是否多条语句操作共享数据
	解决线程问题：
		1 同步代码块 synchronized(对象-锁){代码块} ,对象（可以是任何对象）相当于锁，不能每次都重新创建，这也同步实现锁机制的根本原因
		2 同步方法 private synchronized void sellTickets(){}; 一个方法一进去就是同步代码块的情况
			同步方法锁对象是 this ，静态同步方法的锁对象是 类的字节码对象（class文件）
	同步问题：
		1 效率低 可以接受 
		2 容易产生死锁：两个或以上的线程在争夺资源的过程，发生的一种互相等待的现象
		A锁和B锁，在A，b线程中互相等待
		通过唤醒解决死锁问题
	线程通信：不同种类的线程，操作同一资源：生产 》 资源  》 消费
		1 不同种类的线程都要加上同一把锁 ：锁就是资源对象
		2 通过Object类中等待 wait()，唤醒机制notify(),notifyAll，互相嵌套使用， 实现不同种类之间的通信
		  为什么方法在Object中呢？因为这些放法的调用，必须通过任意锁对象来调，所以必须定义在Object，因为它才能代表任意对象
		  wait()的特点，1 等待时，会立马释放锁，这才能保证不会死锁 2 在哪里等待，唤醒时从哪里开始
		  notify() 唤醒在此对象监视器上等待的单个线程，唤醒并不代表可以立马执行，必须重新抢执行
50 线程池
	1 Runnable 或者 Callable<V>
	2 Callable 有返回值V，可以抛异常
51 定时器 Timer TimerTask
52 设计思想：面向对象的设计思想 高内聚，低耦合，维护性，扩展性，可复用，几种常见的设计思想
52 设计模式：是一种设计思想
	对象模式 - 创建对象  工厂模式 ，单例模式
	结构模式 - 对象内结构
	行为模式 - 对象内方法
	工厂模式：有一个单独的类，专门负责创建特定的对象
		优点：每个类只负责自己的功能 高内聚
		缺点：代码量大
	单例模式：创建的对象在内存中只有一个，并且要提供给被人使用
		1 私有化构造方法（不让别人创建对象，保证唯一） 2 在成员位置创建一个对象 3 提供一个公共访问的方法
		优点：避免创建重复的对象，节省资源
		1 饿汉式（随着类的加载创建对象） 
		2 懒汉式（在使用的时候才创建对象）可能会有线程安全问题存在，所以创建对象方法要加synchronized
			1 懒加载 （延迟加载） 2 线程安全问题
54 Runtime :每个Java程序都有一个Runtime实例对象，使应用程序能够与其运行的环境相连接，也就是调用系统命令，例如在windows中可以执行dos命令
	Runtime r = new Runtime(); r.exec("calc");//调用windows计算器
55 GUI 图形用户接口
   CLI 命令行用户接口
56 java 标准包   Javax 扩展包
57 事件源  事件  事件处理  事件监听
58 适配器模式  接口  适配器实现接口（空实现抽象类）  具体实现类继承适配器，重写想要具体实现的方法
59 关于接口实现和继承： 接口实现可以当作继承体系来用 
60 窗体布局：
	1 流式布局 从左到右 从上到下  
	2 边界布局 东西南北中
	3 网格布局 矩阵的方式
	4 网格包布局 矩阵不规则存放
	5 卡片布局 多张卡片重叠，点击卡片，显示对应区域，菜单切换
61 局部匿名内部类方法局部变量，局部变量必须finall，因为匿名内部类调用局部变量可能会出现对象被垃圾的问题
62 netBean 一款针对于Java界面Gui开发工具，
63 网络编程
	 网络模型
		1 OSI 开放系统互连
		2 TCP/IP参考模型
	IP地址的组成：网络号段+主机号段
		A类：第一号段为网路号段+后三段的主机号
				一个网络号段：256*256*256=16777216
		B类：前二号段+后二段的主机号
				前两个号段位：256*256 = 65536
		C类：前三号段+一位主机号段
				前三号段：256  一般公司用
	192.168.x.x 是私有地址（就是在互联网不使用，用在局域网），还有10.x.x.x，172.16.0.0--172.31.255.255、
	127.0.0.1 本机地址（回环地址）
	x.x.x.255 广播地址（跟所有人通信）
	x.x.x.0   网络地址
	端口
		正在运行的程序的标识。
		有效端口0~65536 ，其中~1024是系统端口或者保留端口
	协议
		通信的规则
		UDP:数据打包，数据有限制64k，不建立连接，不可靠，速度快
		TCP:三次握手协议：建立连接通道，数据无限制，速度慢，可靠
	Socket:网络套接字：IP地址+端口
		原理
			通信的两端都有Socket
			网络通信其实就是Socket间的通信
			数据在两个Socket间通过IO传输
	接收数据时阻塞线程，启动之后会一直等着接收数据
64 类的加载：加载，连接，初始化
	加载的时机：1 创建类的实例 2 访问类的静态变量或赋值 ，方法 3 初始化子类 4 直接使
	直接使用Java.exe命令运行 4 使用反射创建类或接口对应的类
	类加载器：负责将class文件加载到内存，并创建Class对象lass对象
		1 根类加载器 Java核心类的加载，jdk中
		2 扩展类加载器
		3 系统类加载器
65 反射：动态获取数据和对象的思想，具体实现机制可以很多，可以是项目更灵活，变成动态的，可变的，稍微智能型的

	就是通过class文件对象去使用该文件中的成员变量，构造方法，成员方法
		不需要 Object o = new Object(); 这种方式创建对象，再使用
		Class类的对象:里面是三个对象，然后使用对应的对象去调方法
			成员变量：Field
			构造方法：Constructor
			成员方法：Method
		方式1 Person p = new Person(); Class c = p.getClass();
		方式2 Class c2 = Person.class; 数量类型的类中都有这个class
		方式3 Class c3 = Class.forName("cn.org.Person");  必须是全路径
	应用：
		1 面向配置文件开发，代码是动态可变的，配置框架
		2 通过反射可以绕过一些Java编译的规范
		
66 泛型是给编译器看的，为了强制开发者开发习惯，少犯错
67 动态代理：程序在运行过程中，代替别的对象做事，刚开始并不知道要替谁做，只要在运行时谁需要用到时就代理谁
68 模板设计模式：提供一个模板，具体实现在子类中
	装饰模式：可以组合使用
69 枚举类：简化书写
70 Java三大特性
	封装：安全，复用，高内聚，低耦合，可维护
	继承：复用，体系化项目结构。不能说为了多态而用继承，因为体系间本身存在多态的特性
	多态：我需要你是什么形态就可以是什么形态，增加开发智能型（一成不变的，不可变的就很生硬，不灵活
	），提高开发效率和简单型（不支持的语言可能需要做很多逻辑处理最后得到）
	
71 继承 抽象类 接口
	1.java中类不支持多继承,只能单继承,但是可以多实现;
	2.java 中接口之间支持多继承,接口可以继承多个继承;
     什么时候用继承，有什么好处：继承主要是为了复用，明确多个对象都需要使用同一部分功能时就可以抽离出来继承
     什么时候用接口，有什么好处：接口主要是为了扩展，针对于不确定有多少个对象实现同一部分功能
     相同点：都是复用代码，都是多个对象实现或使用同一部分功能
     不同点：继承时明确有哪几个对象，接口不确定全部，继承偏重于继承功能，继承就用可以不重写，接口偏重于实现各自特性的功能
	必须自己实现，功能必须有自己的特性，继承时对象必须有自己的特性，但是继承的方法多个对象可以相同
    抽象类是继承体系：继承只能单继承，问题就是如果一个对象需要多个抽象类的功能时，无法同时继承多个抽象类，
    但是可以通过继承体系，不断继承 A 继承 B, B继承C，C继承D的体系，把多个抽象类最终继承到一个类A中，也可以
    实现同时实现多个接口的场景，问题是麻烦，不灵活，但是好处还是就是 代码复用性更高，牺牲了灵活性，但是提高了
   复用性，提高了开发效率，简化了使用难度
    接口是实现体系：实现可以同时实现多个接口
    抽象类：更像是对子类的约束，就是你继承我，你就必须实现我的功能，相对于接口而言，更明确，更约束，
    明确角度：普通类  > 继承  > 抽象类 > 接口 ，明确对象功能程度，明确使用功能的对象种类和数量程度
    灵活角度：接口 > 抽象类 > 继承 > 普通类  ，对象的属性，功能，使用对象的种类和数量 灵活性依次降低，接口最高，
    灵活性也体现了功能的可扩展性
    理解：接口：就是我，我提供了画布，至于谁来画，画什么内容，不确定，不重要，有多少都可以，画什么都行
              继承：就是我提供了画布，并且上面已经有一副画好的画，或者是画的轮廓（约束），并且提供了涂改功能，至于谁来用，
	有多少人来用
	用画好的还是自己重新画，在确定与不确定之间，也就是它可以确定，因为画好的画就是针对某个人的需求
	那么就有确定的人，也可以不确定，就是这画好的画同样可以用很多其它人喜欢，至于具体是谁，现在可以不
	确定，至于它是否想要重新画也可以不确定，但是确定的是某个或某些人可能存在想要一副画或者画一副画
 72 springboot
	ioc/di 控制翻转/依赖注入 ：是spring框架的容器，并且这个容器提供了添加实例化对象的方式 和注入实例化对象的方式，提高开发效率，降低使用难度，实现开闭原则OCP
	隔离变化，不稳定的代码
	约定配置（自动装配）：不需要开发者写大量的配置，提高开发效率，降低使用难度，把第三方的对象，加载的IOC容器
	注入方式：1 策略模式 byType byname  @Qulifier 一个接口存在多个实例化对象，选择哪个对象使用的策略模式
			  2 属性注入：配置文件编写对象属性 ，把对象变化隔离到配置文件中
	实例化对象的方式： 1 构造函数 2 对象属性 提供set方法 @
	通常使用注解的方式:
	@compent 基础组件/ 容器对象实例化
	@controller @service @rosipotory 衍生组件 容器对象实例化，并且标识了
	@configration  @bean 高级组件 提供了灵活实例化对象的方式 例如配置内属性实例化到具体对象 
	spring的配置文件里的属性绑定
	@value("${配置文件里的key}")
	监听检测：spring的代码监听和检测机制非常强大，它监听检测了基本上所有语法不规范和隐藏bug的代码，这点很强大，把问题全部暴露在编码阶段，并且必须解决，保住了代码健壮性
	语法，约定：语法和约定规范保住了语言的健壮性
	发现机制/应用机制/修改机制：如果自己写一段逻辑，修改spring框架原先的逻辑，
	1 使用spring提供特定的注解标识
	2 使用实现spring提供接口的方式，默认会使用重写的方法？这是是问号，为啥是默认，为啥就会使用重写的，不清楚原理，通过继承重写是不行的，外层必须是通过实现接口
73配置文件的好处
	1 集中性 2 清晰性 3 动态性（随时可以改变，不需要改代码，重新编译项目，重新打包项目，不需要动项目的业务逻辑这点很重要，在生成环境中，能不动则不动）
	4 不需要修改业务逻辑（这个是使用配置文件的前提，才有以上的好处，如果修改配置文件，就要修改业务逻辑，那么没有任何意义，就可以定义的常量类）
	5 不需要重启服务器 这点也很重要
74 七月课程
	1 知识很系统 2 提出的思想，引出的问题，涉及的点很多，很全面 3 对于思想的理解，解释比较深刻和易懂，有些解释很牵强和片面我不完全认同 4 扩散性提及别的点
	5 为什么有，用于什么场景，怎么实现的，有什么好处 这点很重要，听得很舒服 6 后面讲业务的时候，很多原理和机制就没有再讲，没有解释里面的机制，为什么是这样
		
75 设计过程
	起初是为了解决某个问题，或者实现某种思想，达到某个目的，灵活，动态，智能，OCP
	然后提出了一种解决方案
	但是这种方案又隐含了原来没有的一系列问题，还必须使用它，并且没有更好的解决方案，或者是这一系列问题是任何方案都无法回避的问题，想要它就必然要面对它
	那么只能继续解决改变引发的一系列问题
	这就是语言思想，把呆板，生硬的语言代码，变成一种灵活，动态，多变的语言，你享受它多变的好处，必然要接受它多变的不易控制，你要想要它的多变，但又要保住它
	不会偏离，才能够使用它，不然就会存在隐患，为了消除隐患，就要控制它，就是通过各种约束，各种条件，各种场景设定，它的每一种变化都能得到控制，从而解决隐患
	让它即灵活，又安全，可用，可控
	设计语言就是设计约束，描述场景，规则下的动态
76 设计思想：为什么要懂设计思想
	1 学习：优美，巧妙的代码都包含了很多设计思想，如果你不懂思想，你就不知道为什么要这样写，这样写有什么好处，代码美在哪里，巧妙在哪里，你就看不懂，就很难理解
	就很难接受，也就很难学习
	2 应用：生搬硬套使用别人的设计模式，只能解决特定的问题，如果遇到新的问题和场景，你就无法应用思想找到新的解决方案，解决问题的能力才是重点
	3 积累：技术的积累，解决问题的积累 ，业务的积累，场景的积累，只有积累才能设计出完善的语言，思想是可以设计优美，但没有积累连语言都设计不出来，何谈优美
77 深入研究：使用的时候再去研究是一种方式，但前提是你知道它，大概了解它是干嘛的，有什么用，如果你连它的存在都不知道，你怎么知道要去研究它
		这就引发一个概念，技术的广度和深度，技术的广度必须足够，不然就无法解决很多遇到新的问题，技术的深度要有选择，没有就连实现功能都做不到，用到就深入，没用到看需求和兴趣
		如果你想要有解决问题的能力，技术的广度是前提，是不断积累的，继而才是技术的深度研究，是深入研究的，不然就是一脸懵逼，无从下手
		没有技术的广度，遇到的任何一个问题都是无从下手，难入登天，但是如果有了，所有有可能涉及到的场景，技术，你都见过，那么遇到问题时需要做的就是研究它，这点很不是那么
		容易，能有从下手就成功了一半了，但是很多人都没有这方面积累，也就没有这个能力
78 注解
	注解的应用：为什么要使用注解，有什么好处
	1 注解的数据获取是通过反射机制，反射就是动态的，程序运行时，这样我们就可以对程序运行时的数据进行处理
	2 注解的使用方式，在需要的地方，使用注解，打上标识，并可以给值，这样反射时，就可以拿到这个注解所有被用的地方所想要传入的数据，也就是所有使用注解的地方可以
	做业务处理
	程序中携带信息的方式
	1.通过注解来携带信息,然后通过反射来读取信息
	2.通过文件来携带信息,然后通过IO来读取信息
	3.HTTP请求
	
79 SPI 	机制/思想  模块 / 解决方案  可以是很多对象，或者很多对象组成的模块，很多模块组成的大模块，整体的切换
	基于interface   策略模式+配置文件
	@primar @条件注解  具体/粒度小 针对于一个对象   一个对象的切换
	必须是基于interface 才有扩展切换的可能
	切换的方式就是 策略模式和配置文件
80 异常统一处理
	@ControllerAdvice  
	class ExceptionHandleStore{
	@ExceptionHandle(value = Exception.class)
	public void exceptionHandel(HttpSevletRequest req,Exception e){};
	}
	异常类型 
	thorwable
	error
	Exception
	
	校验异常
	checkedExecption :必须处理，可以立即处理，也可以继续往外抛，但即使往外抛也是一种处理：编译时候出现的异常：可以确定，必须处理
	RuntimeException :可以不处理,不用处理，也不用往外抛，什么处理都不用：运行时出现的异常，无法预知，所以不用处理
	
	没有extends RuntimeException 的异常基本都是 checkedExecption,继承的都是Exception
	HttpException extends Exception : 编译异常
	HttpException extends RuntimeException: 运行时异常
	
	已知异常   未知异常
81 方法重载
	一个类中 可以用多个方法  ，方法名相同，参数不同的
	好处：很多方法可以取同一个方法名，因为很多场景就是很多不用的方法，处理不同的数据，方法名就应该相同，也省的取名杂乱
82 配置 和 对象映射:类的机制进，行对象映射实例化
	lin.codes[10000] = "通用异常"
	lin.codes[10001] = "通用错误"
	
	@PropertySource(value = "classpath:config/exception_code.property") 资源文件的路径
	@ConfigurationProperties(prefix = "lin") 匹配key的前缀
	@Compent 类对象交给spring管理，spring管理了这个类对象，才能对这个类对象实例化
	class ExceptionPropertyConfiguration{
		Map<Integer,String>  codes = new HashMap<>();  这里的 codes 命名会和配置文件中 key中的 lin.codes进行匹配
		如果这里不是一个Map 是一个对象，也是一样的，定义成员变量的时候，匹配key里的字段就可以映射
	}
	@value("${propertyKey}")  主配置里的某个属性配置映射到类成员变量上
83 springboot  controller控制器接收参数的方式：通过注解的方式标识是为了区分参数的来源，从而实现更强大复杂的别的方式参数注入
	1 URL
		a 路径参数
			home/banner/1
			@RequsetMapping(value = "home/banner/{id}")
			public void banner(@){@PathVariable Integer id};
			
			@RequsetMapping(value = "home/banner/{bannerId}")
			public void banner(@){@PathVariable(name = bannerId) Integer id};//参数名不对应的情况，通过命名name匹配
		B home/banner/1?name=七月
			@RequsetMapping(value = "home/banner")
			public void banner(@PathVariable Integer id,@RequestParam String name){};
	2 request body域，head信息	
		  home/banner
			{"name":qiyue,"age":17}  request post 请求放在body里的json字符串
			@RequsetMapping(value = "home/banner")
			public void banner(@RequestBody Person person){};//通过对象接收 推荐每一个post请求，创建一个对应的对象来接收
			public void banner(@RequestBody Map<Sring,Object> data){};//通过map接收  Object 涉及装箱，拆箱，影响性能 不推荐
84 lombok 模板化代码 JAR-269 代码规范约束
	1 安装 ider plugin 可以直接安装 2 pom 引入依赖
	2 @data 包含了一系列注解   @Setter @GetTer @ToString @EqueaAndHashcode 
	3 构造函数的注解：@AllArgsConstructor  @NoArgsConstructor(无参构造函数，当存在有参数构造函数时，无参构造函数就被覆盖没有了，需要重新写)
	@RequireConstructor 不为空的构造函数
	4 属性注解：@NonNull 不为空
	5 @Builder 会为对象默认创建一个private 的私有无参构造函数，那么外面想要new 无参构造函数时需要在类里，重新定义一个public 的无参构造函数
	Person person = Person.Builder.Age(17).Name("qiyue").build();//builder 实例化对象的方式，无法使用，必须要有@Getter，对象才对外开放
85 参数校验 JAR-303  BeanValidation  提供的提案  自己生成
	Hibernate-validation
	注解：@Validated 必须加在类上才会生效
	
	@Validated
	class validationTest{
		@RequsetMapping(value = "home/banner")
		public void banner(@PathVariable @Max(10) Integer id,@RequestParam String name){};
		public void banner(@PathVariable @Max(value = 10,message = "最大值不能超过10") Integer id,@RequestParam String name){};//自定义message
		@Min 最小值 @Max 最大值		 @ Range 范围
		
		{"name":qiyue,"age":17}  request post 请求放在body里的json字符串
		@RequsetMapping(value = "home/banner")
		public void banner(@RequestBody @Validated Person person){};//必须在参数上加上@Validation 实体类里的校验规则才会生效,这里也可以使用@Valid
		
		@valid 是Java提供的
		@Validated 是spring开发的
		两者都是开启参数校验的开关，地位等同，只不过@validation 扩展性更好
			
		class Person{
			pirvate Stirng name;
			@Length(min = 1,max = 10,message)
			private Integer age
			
			@valid //级联校验注解，对类里引用的类对象进行校验，必须标识
			private School school;
			
			class School{
				@Length(value = 2)
				private String schoolName;
			}
		}
	}
	
		
	
	
	
	